//---------------------------------------------------------------------
//---------------------------------------------------------------------
// The Nonlinear Game Engine (NGE) version 1.0
// (c) Mikael Fridenfalk
// All rights reserved
// Pending patent SE2330492-6
// The engine is a template for use in the course:
// Real-Time Graphics Programming for Games 1, 7.5 c, 2024
// Uppsala University, Sweden
// Other use requires a written permission from the copyright holder
//---------------------------------------------------------------------
//---------------------------------------------------------------------
#include "Prim.h"
//---------------------------------------------------------------------
//---------------------------------------------------------------------
Prim::Prim(){
 //---------------------------------------------
 mPrimV = new PRIM_STRUCT[PRIM_MAX_N];
 //---------------------------------------------
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Tranparent Triangle Primitives
//---------------------------------------------------------------------
//---------------------------------------------------------------------
Prim::~Prim(){
 delete [] mPrimV;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Prim_Clear(){
 mVec0.clear();
 mVec.clear();
 mPrimN = 0;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Prim_SortVector(){
 //-----------------------------------------------------
 // A1.2
 //-----------------------------------------------------
 //Sort mVec, where the first value of the map is the
 //Prim <integer> index that the element points to, as a function
 //of the second value, the <double> distance from the object to
 //the camera. Sorting is performed in reverse order, such that
 //objects farthest away, are placed first in mVec, since they
 //have to be rendered first.
 //-----------------------------------------------------
 //It is allowed to use a custom data structure to implement this
 //method, but not recommended. It is better to learn how the
 //C++ STL map data structure works for future use, as this is one
 //of the most useful features of STL.
 //-----------------------------------------------------
 //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//[ A1.2
 std::sort(mVec.begin(), mVec.end(), [](const std::pair<double, int>& a, const 
std::pair<double, int>& b) {
 return a.first > b.first;//Sort by distance in descending order
 });
 //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//] A1.2
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
int Prim::Get_PrimN(){return mPrimN;}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// 3D Math
//---------------------------------------------------------------------
//---------------------------------------------------------------------
inline double Prim::DotProd(double a[3], double b[3]){
 return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
double Prim::Length(double a[3]){
 return sqrt(DotProd(a,a));
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
inline double Prim::Dist(double a[3], double b[3]){
 double d[3]; For (i,3) d[i] = a[i] - b[i];
 return Length(d);
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Normalize(double a[3]){
 double invD = 1./Length(a); For (i,3) a[i] *= invD;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
inline void Prim::CrossProd(double a[3], double b[3], double c[3]){
 c[0] = a[1]*b[2] - a[2]*b[1];
 c[1] = a[2]*b[0] - a[0]*b[2];
 c[2] = a[0]*b[1] - a[1]*b[0];
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Minimal Sphere Triangle Collision Physics
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// p1
// pc*--->mPlayerR *
// nx=n1 * * * * nx=n0
// * *
// * *
// p2 ***************** p0
// * pc: center of sphere
// nx=n2 n: norm out from screen
//---------------------------------------------------------------------
//---------------------------------------------------------------------
bool Prim::Coll_SphTri(double p0[3], double p1[3],
 double p2[3], double n[3], double K){
 //------------------------------------------
 //------------------------------------------
 double pc0[3], pc1[3], v[3][3], nx[3], e[3];
 //------------------------------------------
 //------------------------------------------
 For (i,3) pc0[i] = (double)mPlayerPos[i] - p0[i];
 double dist = DotProd(n,pc0);
 if (fabs(dist) >= mPlayerR) return false;
 //------------------------------------------
 //------------------------------------------
 For (i,3){
 pc1[i] = (double)mPlayerPos[i] - p1[i];
 v[0][i] = p1[i] - p0[i]; v[1][i] = p2[i] - p1[i];
 v[2][i] = p0[i] - p2[i];}
 For (m,3){
 CrossProd(v[m],n,nx);
 if (DotProd(nx,m==1?pc1:pc0) >= 0.) return false;}
 //------------------------------------------
 //------------------------------------------
 // Foothold Dynamics
 //------------------------------------------
 //------------------------------------------
 mFoothold = n[1] > mFoothold ? n[1] : mFoothold;
 if (mFoothold > .7){
 For (i,3) mFlyVel[i] = 0.;
 K = 1.;//Use preset K for foothold to avoid jitter
 }
 //------------------------------------------
 //------------------------------------------
 // Proportional Compensation
 //------------------------------------------
 //------------------------------------------
 For (i,3){//error = reference - actual
 e[i] = (mPlayerR - fabs(dist)) * n[i];
 mPlayerPos[i] += dist > 0 ? K*e[i] : -K*e[i];}
 //------------------------------------------
 //------------------------------------------
 return true;
 //------------------------------------------
 //------------------------------------------
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
bool Prim::Coll_Spheres(double objCenter[3], double sphBBoxR){
 double playerPos[3]; For (i,3) playerPos[i] = mPlayerPos[i];
 return Dist(playerPos,objCenter) < mPlayerR + sphBBoxR;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Core Methods
//---------------------------------------------------------------------
//---------------------------------------------------------------------
bool Prim::Add_Prim(PRIM_STRUCT& x){
 //---------------------------------------------Center
 For (j,3){
 double sum = 0.;
 For (i,x.N) sum += x.v[i][j];
 x.p[j] = sum/double(x.N);
 }
 //---------------------------------------------SpBBox
 double max = -1000., p[3], r;
 For (i,x.N){
 For (j,3) p[j] = x.v[i][j];
 r = Dist(p,x.p);
 if (max < r) max = r;
 }
 x.R = max;
 //---------------------------------------------Normal
 double s[3], t[3];
 For (j,3){
 s[j] = x.v[1][j] - x.v[0][j];
 t[j] = x.v[2][j] - x.v[0][j];}
 CrossProd(s,t,mC);
 Normalize(mC);
 For (i,3) x.n[i] = mC[i];
 //---------------------------------------------Collision Physics
 if (x.collK != 0. && Coll_Spheres(x.p,x.R)){
 Coll_SphTri(x.v[0],x.v[1],x.v[2],x.n,x.collK);
 if (x.N == 4)
 Coll_SphTri(x.v[0],x.v[2],x.v[3],x.n,x.collK);}
 //---------------------------------------------Frustum Culling
 if (Frustum_CullObj(x.p,x.R) > 0) return false;
 //---------------------------------------------
 double d[3];
 //---------------------------------------------
 if (mMode == PLAY_MODE) For (i,3) d[i] = x.p[i] - mEye[i];
 else For (i,3) d[i] = x.p[i] - mEyeDesign[i];
 //---------------------------------------------
 double sumSq = d[0]*d[0] + d[1]*d[1] + d[2]*d[2];
 //---------------------------------------------
 if (x.blendON) mVec.push_back(pairX(mPrimN, sumSq));
 else mVec0.push_back(mPrimN);
 //---------------------------------------------
 mPrimV[mPrimN] = x;//Copy struct object
 //---------------------------------------------
 mPrimN++;
 //---------------------------------------------
 return true;
 //---------------------------------------------
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Draw_Prim(int primIdx){
 //---------------------------------------------
 //---------------------------------------------
 if (mDrawNormals) Draw_Normal(primIdx);
 //---------------------------------------------
 //---------------------------------------------
 bool cullFace = false;
 //---------------------------------------------
 //---------------------------------------------
 int N = mPrimV[primIdx].N;
 //---------------------------------------------
 //---------------------------------------------
 if (mPrimV[primIdx].lightsON) glEnable(GL_LIGHTING);
 else glDisable(GL_LIGHTING);
 //---------------------------------------------
 //---------------------------------------------
 glColor4ubv(mPrimV[primIdx].color);
 //---------------------------------------------
 //---------------------------------------------
 if (cullFace) glEnable(GL_CULL_FACE);
 //---------------------------------------------
 //---------------------------------------------
 if (mPrimV[primIdx].blendON) glEnable(GL_BLEND);
 //---------------------------------------------
 //---------------------------------------------
 glNormal3dv(mPrimV[primIdx].n);
 //---------------------------------------------
 //---------------------------------------------
 if (mPrimV[primIdx].texIdx >= 0){
 glBindTexture(GL_TEXTURE_2D, mPrimV[primIdx].texIdx);
 glEnable(GL_TEXTURE_2D);
 }
 //---------------------------------------------
 //---------------------------------------------
 glBegin(N == 3 ? GL_TRIANGLES : GL_QUADS);
 //---------------------------------------------
 //---------------------------------------------
 For (i,N){
 glTexCoord2dv(mPrimV[primIdx].uv[i]);
 glVertex3dv(mPrimV[primIdx].v[i]);
 }
 //---------------------------------------------
 //---------------------------------------------
 glEnd();
 //---------------------------------------------
 //---------------------------------------------
 if (mPrimV[primIdx].texIdx >= 0) glDisable(GL_TEXTURE_2D);
 //---------------------------------------------
 //---------------------------------------------
 if (mPrimV[primIdx].blendON) glDisable(GL_BLEND);
 //---------------------------------------------
 //---------------------------------------------
 if (cullFace) glDisable(GL_CULL_FACE);
 //---------------------------------------------
 //---------------------------------------------
 //if (!mPrimV[primIdx].lightsON) glDisable(GL_LIGHTING);
 //else glEnable(GL_LIGHTING);
 //---------------------------------------------
 //---------------------------------------------
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Draw_Prims(){
 //---------------------------------------------
 //---------------------------------------------
 // Draw opaque prims (sorting does not matter)
 //---------------------------------------------
 //---------------------------------------------
 for (auto i = mVec0.begin(); i != mVec0.end(); ++i) Draw_Prim(*i);
 //---------------------------------------------
 //---------------------------------------------
 // Draw transparent prims (sorting matters)
 //---------------------------------------------
 //---------------------------------------------
 if (mSortPrims) Prim_SortVector();
 for (auto const &pair: mVec) Draw_Prim(pair.first);
 //---------------------------------------------
 //---------------------------------------------
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Tests
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Draw_Center(int primIdx){
 //-----------------------
 glPushMatrix();
 //-----------------------
 glTranslated(mPrimV[primIdx].p[0],
 mPrimV[primIdx].p[1],
 mPrimV[primIdx].p[2]);
 //-----------------------
 gluSphere(mQuadratic,.03,16,16);
 //-----------------------
 glPopMatrix();
 //-----------------------
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Draw_Normal(int primIdx){
 //-----------------------
 glDisable(GL_LIGHTING);
 //-----------------------
 glColor3ub(0,0,255);
 //-----------------------
 Draw_Center(primIdx);
 //-----------------------
 double p0[3], p1[3];
 For (i,3){
 p0[i] = mPrimV[primIdx].p[i];
 p1[i] = p0[i] + mPrimV[primIdx].n[i];
 }
 //-----------------------
 glPushMatrix();
 //-----------------------
 glLineWidth(5);
 //-----------------------
 glBegin(GL_LINES);
 glVertex3dv(p0);
 glVertex3dv(p1);
 glEnd();
 //-----------------------
 glTranslated(p1[0],p1[1],p1[2]);
 gluSphere(mQuadratic,.03,16,16);
 //-----------------------
 glPopMatrix();
 //-----------------------
 //glEnable(GL_LIGHTING);
 //-----------------------
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Prim_A1_1(){
 Prim_Clear();
 const bool blendON = true;//Default: true
 const bool lightsON = false;//Default: false
 const int texIdx = 3;
 const double collK = 0;
 const UCHAR alpha = 160;
 // BACK
 PRIM_STRUCT backQuad = {
 4, texIdx, blendON, lightsON, collK,
 {
 {1, 0, -1}, 
 {0, 0, -1},
 {0, 1, -1},
 {1, 1, -1}
 },
 {255, 255, 255, alpha},
 {
 {0, 0}, {1, 0}, {1, 1}, {0, 1}
 }
 };
 Add_Prim(backQuad);
 // TOP
 PRIM_STRUCT topQuad = {
 4, texIdx, blendON, lightsON, collK,
 {
 {0, 1, 1}, // LD
 {1, 1, 1}, // RD
 {1, 1, -1}, // RU
 {0, 1, -1} // LU
 },
 {255, 255, 255, alpha},
 {
 {0, 0}, {1, 0}, {1, 1}, {0, 1}
 }
 };
 Add_Prim(topQuad);
 // LEFT
 PRIM_STRUCT leftQuad = {
 4, texIdx, blendON, lightsON, collK,
 {
 {0, 0, -1}, // LD
 {0, 0, 1}, // RD
 {0, 1, 1}, // RU
 {0, 1, -1} // LU
 },
 {255, 255, 255, alpha},
 {
 {0, 0}, {1, 0}, {1, 1}, {0, 1}
 }
 };
 Add_Prim(leftQuad);
 // RIGHT
 PRIM_STRUCT rightQuad = {
 4, texIdx, blendON, lightsON, collK,
 {
 {1, 0, 1}, // LD
 {1, 0, -1}, // RD
 {1, 1, -1}, // RU
 {1, 1, 1} // LU
 },
 {255, 255, 255, alpha},
 {
 {0, 0}, {1, 0}, {1, 1}, {0, 1}
 }
 };
 Add_Prim(rightQuad);
 // BOTTOM
 PRIM_STRUCT bottomQuad = {
 4, texIdx, blendON, lightsON, collK,
 {
 {0, 0, -1}, // LD
 {1, 0, -1}, // RD
 {1, 0, 1}, // RU
 {0, 0, 1} // LU
 },
 {255, 255, 255, alpha},
 {
 {0, 0}, {1, 0}, {1, 1}, {0, 1}
 }
 };
 Add_Prim(bottomQuad);
 // FRONT
 PRIM_STRUCT frontQuad = {
 4,texIdx,blendON,lightsON,collK,
 {
 {0,0,1},//LD
 {1,0,1},//RD
 {1,1,1},//RU
 {0,1,1},//LU
 },
 {255,255,255,alpha},
 {
 {0,0},//LU
 {1,0},//RU
 {1,1},//RD
 {0,1},//LD
 },
 };
 Add_Prim(frontQuad);
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Prim::Prim_A1_2(){
 //--------------------------------------------
 //--------------------------------------------
 Prim_Clear();
 //--------------------------------------------
 //--------------------------------------------
 const bool blendON = true;//Default: true
 const bool lightsON = false;//Default: false
 const int texIdx = 3;
 const double collK = 0;
 const UCHAR alpha = 100;
 //--------------------------------------------
 //--------------------------------------------
 // Front
 //--------------------------------------------
 //--------------------------------------------
 PRIM_STRUCT quad = {
 4,texIdx,blendON,lightsON,collK,
 {{0,0,1},{1,0,1},{1,1,1},{0,1,1}},
 {255,255,255,alpha},
 {{0,0},{1,0},{1,1},{0,1}},
 };
 For (j,11){
 double a = 1. - .1 * double(j);//### j = 0 => z-fighting
 For (i,4) quad.v[i][2] = a;
 Add_Prim(quad);
 }
 //--------------------------------------------
 //--------------------------------------------
 //--------------------------------------------
 //--------------------------------------------
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
